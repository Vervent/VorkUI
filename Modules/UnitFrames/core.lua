---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by flori.
--- DateTime: 19/10/2020 23:54
---

local V, C, L = select(2, ...):unpack()
local AddOn, Plugin = ...
local oUF = Plugin.oUF or oUF
local Noop = function() end
local UnitFrames = V["UnitFrames"]

-- Lib globals
local strfind = strfind
local format = format
local floor = floor

-- WoW globals (I don't really wanna import all the funcs we use here, so localize the ones called a LOT, like in Health/Power functions)
local UnitIsEnemy = UnitIsEnemy
local UnitIsPlayer = UnitIsPlayer
local UnitIsFriend = UnitIsFriend
local UnitIsConnected = UnitIsConnected
local UnitPlayerControlled = UnitPlayerControlled
local UnitIsGhost = UnitIsGhost
local UnitIsDead = UnitIsDead
local UnitPowerType = UnitPowerType

UnitFrames.oUF = oUF
UnitFrames.Units = {}
UnitFrames.Headers = {}

UnitFrames.HighlightBorder = {
    bgFile = "Interface\\Buttons\\WHITE8x8",
    insets = {top = -2, left = -2, bottom = -2, right = -2}
}

UnitFrames.AddClassFeatures = {}

UnitFrames.NameplatesVariables = {
    nameplateMaxAlpha = 1,
    nameplateMinAlpha = 1,
    nameplateSelectedAlpha = 1,
    nameplateNotSelectedAlpha = 1,
    nameplateMaxScale = 1,
    nameplateMinScale = 1,
    nameplateSelectedScale = 1,
    nameplateSelfScale = 1,
    nameplateSelfAlpha = 1,
    nameplateOccludedAlphaMult = 1,
}

function UnitFrames:DisableBlizzard()
end

function UnitFrames:ShortValue()
    if self <= 999 then
        return self
    end

    local Value

    if self >= 1000000 then
        Value = format("%.1fm", self / 1000000)
        return Value
    elseif self >= 1000 then
        Value = format("%.1fk", self / 1000)
        return Value
    end
end

function UnitFrames:UTF8Sub(i, dots)
    if not self then return end

    local Bytes = self:len()
    if (Bytes <= i) then
        return self
    else
        local Len, Pos = 0, 1
        while(Pos <= Bytes) do
            Len = Len + 1
            local c = self:byte(Pos)
            if (c > 0 and c <= 127) then
                Pos = Pos + 1
            elseif (c >= 192 and c <= 223) then
                Pos = Pos + 2
            elseif (c >= 224 and c <= 239) then
                Pos = Pos + 3
            elseif (c >= 240 and c <= 247) then
                Pos = Pos + 4
            end
            if (Len == i) then break end
        end

        if (Len == i and Pos <= Bytes) then
            return self:sub(1, Pos - 1)..(dots and "..." or "")
        else
            return self
        end
    end
end

function UnitFrames:UpdateAbsorbOverride(event, unit)
    if(not unit or self.unit ~= unit) then return end
    local element = self.Absorb

    --[[ Callback: Absorb:PreUpdate(unit)
    Called before the element has been updated.

    * self - the Absorb element
    * unit - the unit for which the update has been triggered (string)
    --]]
    if(element.PreUpdate) then
        element:PreUpdate(unit)
    end

    local curDamageAbsorb = UnitGetTotalAbsorbs(unit)
    local curHealAbsorb = UnitGetTotalHealAbsorbs(unit)
    local cur

    if curDamageAbsorb > curHealAbsorb then
        element.colors = self.colors.absorbs.damageAbsorb
        cur = curDamageAbsorb - curHealAbsorb
    else
        element.colors = self.colors.absorbs.healAbsorb
        cur = curHealAbsorb - curDamageAbsorb
    end

    local max = UnitHealthMax(unit)

    if(UnitIsConnected(unit)) then
        element.Slant:Slant(0, cur/max);
    else
        element.Slant:Slant(0, 1);
    end

    element.cur = cur
    element.max = max

    --[[ Callback: Absorb:PostUpdate(unit, cur, max)
    Called after the element has been updated.

    * self - the Health element
    * unit - the unit for which the update has been triggered (string)
    * cur  - the unit's current health value (number)
    * max  - the unit's maximum possible health value (number)
    --]]
    if(element.PostUpdate) then
        element:PostUpdate(unit, cur, max)
    end
end

function UnitFrames:UpdatePowerOverride(event, unit)
    if(self.unit ~= unit) then return end
    local element = self.Power

    --[[ Callback: Power:PreUpdate(unit)
    Called before the element has been updated.

    * self - the Power element
    * unit - the unit for which the update has been triggered (string)
    --]]
    if(element.PreUpdate) then
        element:PreUpdate(unit)
    end

    local displayType, min
    if(element.displayAltPower) then
        displayType, min = element:GetDisplayPower()
    end

    local cur, max = UnitPower(unit, displayType), UnitPowerMax(unit, displayType)

    if(UnitIsConnected(unit)) then
        element.Slant:Slant(0, cur/max);
    else
        element.Slant:Slant(0, 1);
    end

    element.cur = cur
    element.min = min
    element.max = max
    element.displayType = displayType

    --[[ Callback: Power:PostUpdate(unit, cur, min, max)
    Called after the element has been updated.

    * self - the Power element
    * unit - the unit for which the update has been triggered (string)
    * cur  - the unit's current power value (number)
    * min  - the unit's minimum possible power value (number)
    * max  - the unit's maximum possible power value (number)
    --]]
    if(element.PostUpdate) then
        element:PostUpdate(unit, cur, min, max)
    end
end

function UnitFrames:UpdatePowerColorOverride(event, unit)
    if(self.unit ~= unit) then return end
    local element = self.Power

    local pType, pToken, altR, altG, altB = UnitPowerType(unit)

    local r, g, b, t
    if(element.colorDisconnected and not UnitIsConnected(unit)) then
        t = self.colors.disconnected
    elseif(element.colorTapping and not UnitPlayerControlled(unit) and UnitIsTapDenied(unit)) then
        t = self.colors.tapped
    elseif(element.colorThreat and not UnitPlayerControlled(unit) and UnitThreatSituation('player', unit)) then
        t =  self.colors.threat[UnitThreatSituation('player', unit)]
    elseif(element.colorPower) then
        if(element.displayType ~= ALTERNATE_POWER_INDEX) then
            t = self.colors.power[pToken]
            if(not t) then
                if(element.GetAlternativeColor) then
                    r, g, b = element:GetAlternativeColor(unit, pType, pToken, altR, altG, altB)
                elseif(altR) then
                    r, g, b = altR, altG, altB
                    if(r > 1 or g > 1 or b > 1) then
                        -- BUG: As of 7.0.3, altR, altG, altB may be in 0-1 or 0-255 range.
                        r, g, b = r / 255, g / 255, b / 255
                    end
                else
                    t = self.colors.power[pType] or self.colors.power.MANA
                end
            end
        else
            t = self.colors.power[ALTERNATE_POWER_INDEX]
        end
    elseif(element.colorClass and UnitIsPlayer(unit))
            or (element.colorClassNPC and not UnitIsPlayer(unit))
            or (element.colorClassPet and UnitPlayerControlled(unit) and not UnitIsPlayer(unit)) then
        local _, class = UnitClass(unit)
        t = self.colors.class[class]
    elseif(element.colorSelection and unitSelectionType(unit, element.considerSelectionInCombatHostile)) then
        t = self.colors.selection[unitSelectionType(unit, element.considerSelectionInCombatHostile)]
    elseif(element.colorReaction and UnitReaction(unit, 'player')) then
        t = self.colors.reaction[UnitReaction(unit, 'player')]
    elseif(element.colorSmooth) then
        local adjust = 0 - (element.min or 0)
        r, g, b = self:ColorGradient((element.cur or 1) + adjust, (element.max or 1) + adjust, unpack(element.smoothGradient or self.colors.smooth))
    end

    if(t) then
        r, g, b = t[1], t[2], t[3]
    end

    if(b) then
        element:SetVertexColor(r, g, b)

        local bg = element.bg
        if(bg) then
            local mu = bg.multiplier or 1
            bg:SetVertexColor(r * mu, g * mu, b * mu)
        end
    end

    --[[ Callback: Power:PostUpdateColor(unit, r, g, b)
    Called after the element color has been updated.

    * self - the Power element
    * unit - the unit for which the update has been triggered (string)
    * r    - the red component of the used color (number)[0-1]
    * g    - the green component of the used color (number)[0-1]
    * b    - the blue component of the used color (number)[0-1]
    --]]
    if(element.PostUpdateColor) then
        element:PostUpdateColor(unit, r, g, b)
    end
end

function UnitFrames:UpdateHealthOverride(event, unit)
    if(not unit or self.unit ~= unit) then
        return
    end
    local element = self.Health

    if(element.PreUpdate) then
        element:PreUpdate(unit)
    end

    local cur, max = UnitHealth(unit), UnitHealthMax(unit)

    if(UnitIsConnected(unit)) then
        element.Slant:Slant(0, cur/max);
    else
        element.Slant:Slant(0, 1);
    end

    element.cur = cur
    element.max = max

    if(element.PostUpdate) then
        element:PostUpdate(unit, cur, max)
    end
end

function UnitFrames:UpdateHealthColorOverride(event, unit)
    if(not unit or self.unit ~= unit)
    then
        return
    end
    local element = self.Health

    local r, g, b, t
    if(element.colorDisconnected and not UnitIsConnected(unit)) then
        t = self.colors.disconnected
        --print ("colorDisconnected")
    elseif(element.colorTapping and not UnitPlayerControlled(unit) and UnitIsTapDenied(unit)) then
        t = self.colors.tapped
        --print ("colorTapping")
    elseif(element.colorThreat and not UnitPlayerControlled(unit) and UnitThreatSituation('player', unit)) then
        t =  self.colors.threat[UnitThreatSituation('player', unit)]
        --print ("colorThreat")
    elseif(element.colorClass and UnitIsPlayer(unit))
            or (element.colorClassNPC and not UnitIsPlayer(unit))
            or (element.colorClassPet and UnitPlayerControlled(unit) and not UnitIsPlayer(unit)) then
        local _, class = UnitClass(unit)
        t = self.colors.class[class]
        --print ("colorClass")
    elseif(element.colorSelection and unitSelectionType(unit, element.considerSelectionInCombatHostile)) then
        t = self.colors.selection[unitSelectionType(unit, element.considerSelectionInCombatHostile)]
        --print ("colorSelection")
    elseif(element.colorReaction and UnitReaction(unit, 'player')) then
        t = self.colors.reaction[UnitReaction(unit, 'player')]
        --print ("colorReaction")
    elseif(element.colorSmooth) then
        r, g, b = self:ColorGradient(element.cur or 1, element.max or 1, unpack(element.smoothGradient or self.colors.smooth))
        --print ("colorSmooth")
    elseif(element.colorHealth) then
        t = self.colors.health
        --print ("colorHealth")
    end

    if(t) then
        r, g, b = t[1], t[2], t[3]
    end

    if(b) then
        --element:SetStatusBarColor(r, g, b)

        element:SetVertexColor(r, g, b)

        local bg = element.bg
        if(bg) then
            local mu = bg.multiplier or 1
            bg:SetVertexColor(r * mu, g * mu, b * mu)
        end
    end

    --[[ Callback: Health:PostUpdateColor(unit, r, g, b)
    Called after the element color has been updated.

    * self - the Health element
    * unit - the unit for which the update has been triggered (string)
    * r    - the red component of the used color (number)[0-1]
    * g    - the green component of the used color (number)[0-1]
    * b    - the blue component of the used color (number)[0-1]
    --]]
    if(element.PostUpdateColor) then
        element:PostUpdateColor(unit, r, g, b)
    end
end

function UnitFrames:MouseOnPlayer()

end

function UnitFrames:Highlight()

end

function UnitFrames:PostCreateAuraBar(bar)

end

function UnitFrames:UpdateBuffsHeaderPosition(height)

end

function UnitFrames:UpdateDebuffsHeaderPosition()

end

function UnitFrames:CustomCastTimeText(duration)

end

function UnitFrames:CustomCastDelayText(duration)

end

function UnitFrames:CheckInterrupt(unit)

end

function UnitFrames:CheckCast(unit, name, rank, castid)

end

function UnitFrames:CheckChannel(unit, name, rank)

end



function UnitFrames:PreUpdateHealth(unit)

end

function UnitFrames:DisplayPlayerAndPetNames(event)

end

function UnitFrames:PostUpdateHealth(unit, min, max)

end

function UnitFrames:PostUpdatePower(unit, current, min, max)

end

function UnitFrames:UpdateAltPower(minimum, current, maximum)

end

function UnitFrames:SetAuraTimer(elapsed)

end

function UnitFrames:CancelPlayerBuff(index)

end

function UnitFrames:PostCreateAura(button)

end

function UnitFrames:PostUpdateAura(unit, button, index, offset, filter, isDebuff, duration, timeLeft)

end

function UnitFrames:Update()
    for _, element in ipairs(self.__elements) do
        element(self, "UpdateElement", self.unit)
    end
end

function UnitFrames:DisplayNameplatePowerAndCastBar(unit, cur, min, max)

end

function UnitFrames:RunesPostUpdate(runemap)

end

function UnitFrames:UpdateTotemTimer(elapsed)

end

function UnitFrames:UpdateTotemOverride(event, slot)

end

function UnitFrames:GetPartyFramesAttributes()
    return
   ""
end

function UnitFrames:GetPetPartyFramesAttributes()
    return
   ""
end

function UnitFrames:GetRaidFramesAttributes()

    return
   ""
end

function UnitFrames:GetPetRaidFramesAttributes()
  return ""
end

function UnitFrames:Style(unit)
    if (not unit) then
        return
    end

    local Parent = self:GetParent():GetName()

    if (unit == "player") then
        UnitFrames.Player(self)
    elseif (unit == "target") then
        UnitFrames.Target(self)
    end

    return self
end

function UnitFrames:CreateUnits()

    local Player = oUF:Spawn("player", "VorkuiPlayerFrame")
    Player:SetPoint("CENTER", nil, "CENTER", -235, 0)
    Player:SetSize(300, 60)

    local Target = oUF:Spawn("target", "VorkuiTargetFrame")
    Target:SetPoint("CENTER", nil, "CENTER", 235, 0)
    Target:SetSize(256, 60)

    self.Units.Player = Player
    self.Units.Target = Target

end

function UnitFrames:UpdateRaidDebuffIndicator()

end

function UnitFrames:Enable()

    oUF:RegisterStyle("Vorkui", UnitFrames.Style)
    oUF:SetActiveStyle("Vorkui")

    self:CreateUnits()
end
